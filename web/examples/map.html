<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<meta http-equiv="X-UA-Compatible" content="ie=edge" />
	<link href='https://api.mapbox.com/mapbox-gl-js/v2.8.2/mapbox-gl.css' rel='stylesheet' />
	<script src='https://api.mapbox.com/mapbox-gl-js/v2.8.2/mapbox-gl.js'></script>
	<script src='https://www.unpkg.com/suncalc@1.9.0/suncalc.js'></script>
	<script src="../dist/mapbox-gl-shadow-simulator.umd.min.js"></script>
	<style>
		body {
			padding: 0px;
			margin: 0px;
		}

		#mapid {
			height: 100vh;
		}

		.mapbox-control-time {
			padding: 20px;
			background-color: white;
		}

		#exposure-gradient-container {
			display: none;
			background-color: white;
			padding: 0 10px 5px;
		}

		#exposure-gradient {
			height: 20px;
			background-image: linear-gradient(to right, rgb(0 0 255/ 0.5), rgb(0 255 0 / 0.5), rgb(255 0 0 / 0.5));
			display: flex;
		}

		#exposure-gradient>div {
			flex: 1;
			border: 1px solid white;
			text-align: center;
			font-weight: bold;
		}
	</style>
	<title>Shade Map Mapbox example</title>
</head>

<body>
	<div id="mapid">
		<div class="mapboxgl-control-container" style="z-index: 2000; pointer-events: auto;">
			<div class="mapboxgl-ctrl-top-left">
				<div class="mapbox-control-time" style="pointer-events: auto;">
					<button id="decrement">-1 hour</button>
					<button id="increment">+1 hour</button>
					<button id="play">Play</button>
					<button id="stop">Stop</button>
					<label><input id="exposure" type="checkbox" autocomplete="off" />Full-day sun exposure</label>
					<button>
						<a href="https://shademap.app/about" target="_blank">Get API key</a>
					</button>
					<span id="loader" style="padding: 3px;"></span>
				</div>
				<div id="exposure-gradient-container">
					<div>Hours of sunlight</div>
					<div id="exposure-gradient"></div>
				</div>
			</div>
		</div>
	</div>
	<script>
		const mapLoaded = (map) => {
			return new Promise((res, rej) => {
				function cb() {
					if (!map.loaded()) {
						return;
					}
					map.off("render", cb);
					res();
				}
				map.on("render", cb);
				cb();
			});
		};
		/* Mapbox setup */
		mapboxgl.accessToken = 'pk.eyJ1IjoiYXpyYWZhbG1hcyIsImEiOiJjbWNnaXhkNjMwbGNqMmpwdGlndXZ2ZnVtIn0.mTHFqXv1Ao_h2QptWhtmlg';
		const map = new mapboxgl.Map({
			container: 'mapid',
			style: 'mapbox://styles/mapbox/streets-v11',
			center: { lng: -122.18578164139899, lat: 47.694878957368815 },
			zoom: 8, // starting zoom
			hash: true
		});
		/* End Mapbox setup */

		/* ShadeMap setup */
		const loaderEl = document.getElementById('loader');
		let now = new Date((SunCalc.getTimes(new Date(), 47.694878957368815, -122.18578164139899).sunrise).getTime() + 60 * 60 * 1000);
		let shadeMap;
		map.on('load', () => {
			shadeMap = new ShadeMap({
				apiKey: "eyJhbGciOiJIUzI1NiJ9.eyJlbWFpbCI6IjFzYWtpYi51ZGRpbkBnbWFpbC5jb20iLCJjcmVhdGVkIjoxNzUxMTI5NjcyMTQ2LCJpYXQiOjE3NTExMjk2NzJ9.kE8qlYMd5W_J_p6rRgiwrcAHr9oHbN_ICx4nRzHyOFI",
				date: now,
				color: '#01112f',
				opacity: 0.7,
				terrainSource: {
					maxZoom: 15,
					tileSize: 256,
					getSourceUrl: ({ x, y, z }) => `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${z}/${x}/${y}.png`,
					getElevation: ({ r, g, b, a }) => (r * 256 + g + b / 256) - 32768,
					_overzoom: 18,
				},
				getFeatures: async () => {
					await mapLoaded(map);
					const buildingData = map.querySourceFeatures('composite', { sourceLayer: 'building' }).filter((feature) => {
						return feature.properties && feature.properties.underground !== "true" && (feature.properties.height || feature.properties.render_height)
					});
					// Print all building polygons that will be used for shadow simulation
					buildingData.forEach((feature, idx) => {
						console.log(`Building polygon #${idx + 1}:`, feature.geometry.coordinates);
					});
					return buildingData;
				},
				debug: (msg) => { console.log(new Date().toISOString(), msg) }
			}).addTo(map);

			// --- Shadow polygon outline logic ---
			let shadowOutlineSource = 'shadow-outline';
			let shadowOutlineLayer = 'shadow-outline-layer';

			function drawShadowOutlines(polygons) {
				const outlineFeatures = polygons.map((coords) => ({
					type: 'Feature',
					geometry: { type: 'Polygon', coordinates: coords },
					properties: {}
				}));
				const outlineGeoJSON = { type: 'FeatureCollection', features: outlineFeatures };
				if (map.getSource(shadowOutlineSource)) {
					map.getSource(shadowOutlineSource).setData(outlineGeoJSON);
				} else {
					map.addSource(shadowOutlineSource, {
						type: 'geojson',
						data: outlineGeoJSON
					});
					map.addLayer({
						id: shadowOutlineLayer,
						type: 'line',
						source: shadowOutlineSource,
						paint: {
							'line-color': '#ff0000',
							'line-width': 2
						}
					});
				}
			}

			// Print and outline all polygons that will be rendered before shadows load
			shadeMap.on('tileloaded', () => {
				if (typeof shadeMap.getShadeMask === 'function') {
					const polygons = shadeMap.getShadeMask();
					const bounds = map.getBounds();
					const sw = bounds.getSouthWest();
					const ne = bounds.getNorthEast();
					const bbox = [sw.lng, sw.lat, ne.lng, ne.lat];
					// Helper: check if any point of polygon is inside bbox
					function polygonInBounds(poly, bbox) {
						return poly.some(([lng, lat]) =>
							lng >= bbox[0] && lng <= bbox[2] && lat >= bbox[1] && lat <= bbox[3]
						);
					}
					polygons.forEach((poly, idx) => {
						if (polygonInBounds(poly, bbox)) {
							console.log(`Visible shadow polygon #${idx + 1} coordinates:`, poly);
						}
					});
					drawShadowOutlines(polygons);
				}
			});

			shadeMap.on('tileloaded', (loadedTiles, totalTiles) => {
				loaderEl.innerText = `Loading: ${(loadedTiles / totalTiles * 100).toFixed(0)}%`;
			});
		});
		/* End ShadeMap setup */

		/* Controls setup */
		let intervalTimer;

		const increment = document.getElementById('increment');
		const decrement = document.getElementById('decrement');
		const play = document.getElementById('play');
		const stop = document.getElementById('stop');
		const exposure = document.getElementById('exposure');
		const exposureGradientContainer = document.getElementById('exposure-gradient-container');
		const exposureGradient = document.getElementById('exposure-gradient');

		increment.addEventListener('click', () => {
			now = new Date(now.getTime() + 3600000);
			shadeMap && shadeMap.setDate(now);
		}, false);

		decrement.addEventListener('click', () => {
			now = new Date(now.getTime() - 3600000);
			shadeMap && shadeMap.setDate(now);
		}, false);

		play.addEventListener('click', () => {
			intervalTimer = setInterval(() => {
				now = new Date(now.getTime() + 60000);
				shadeMap && shadeMap.setDate(now);
			}, 100);
		});

		stop.addEventListener('click', () => {
			clearInterval(intervalTimer);
		})

		exposure.addEventListener('click', (e) => {
			clearInterval(intervalTimer);
			const target = e.target;
			if (!target.checked) {
				shadeMap && shadeMap.setSunExposure(false);
				increment.disabled = false;
				decrement.disabled = false;
				play.disabled = false;
				stop.disabled = false;
				exposureGradientContainer.style.display = 'none';
			} else {
				const { lat, lng } = map.getCenter();
				const { sunrise, sunset } = SunCalc.getTimes(now, lat, lng);
				shadeMap && shadeMap.setSunExposure(true, {
					startDate: sunrise,
					endDate: sunset
				});
				increment.disabled = true
				decrement.disabled = true;
				play.disabled = true;
				stop.disabled = true;

				const hours = (sunset - sunrise) / 1000 / 3600;
				const partial = hours - Math.floor(hours);
				const html = [];
				for (let i = 0; i < hours; i++) {
					html.push(`<div>${i + 1}</div>`)
				}
				html.push(`<div style="flex: ${partial}"></div>`);
				exposureGradientContainer.style.display = 'block';
				exposureGradient.innerHTML = html.join('');
			}
		})
		/* End controls setup */

		// --- Shade Polygon Visualization ---
		function drawShadePolygons() {
			const center = [-122.18578164139899, 47.694878957368815];
			const radius = 1; // km
			const shadeFeatures = [];
			// Get shade mask from ShadeMap (assume shadeMap.getShadeMask() returns array of polygons in [lng, lat] format)
			if (shadeMap && typeof shadeMap.getShadeMask === 'function') {
				const polygons = shadeMap.getShadeMask();
				for (const poly of polygons) {
					shadeFeatures.push({
						type: 'Feature',
						geometry: { type: 'Polygon', coordinates: [poly] },
						properties: {}
					});
				}
			}

			// Add or update the shade polygons source
			if (map.getSource('shade-polygons')) {
				map.getSource('shade-polygons').setData({ type: 'FeatureCollection', features: shadeFeatures });
			} else {
				map.addSource('shade-polygons', {
					type: 'geojson',
					data: { type: 'FeatureCollection', features: shadeFeatures }
				});
				map.addLayer({
					id: 'shade-polygons-layer',
					type: 'fill',
					source: 'shade-polygons',
					paint: {
						'fill-color': '#01112f',
						'fill-opacity': 0.4
					}
				});
			}

			// Add or update the red outline for each shadow polygon
			if (map.getSource('shade-outline')) {
				map.getSource('shade-outline').setData({ type: 'FeatureCollection', features: shadeFeatures });
			} else {
				map.addSource('shade-outline', {
					type: 'geojson',
					data: { type: 'FeatureCollection', features: shadeFeatures }
				});
				map.addLayer({
					id: 'shade-outline-layer',
					type: 'line',
					source: 'shade-outline',
					paint: {
						'line-color': '#ff0000',
						'line-width': 2
					}
				});
			}
		}

		// Draw polygons after shade tiles load
		shadeMap.on('tileloaded', drawShadePolygons);
		// Initial draw
		setTimeout(drawShadePolygons, 2000);
	</script>
</body>

</html>